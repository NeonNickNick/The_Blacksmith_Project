本文档的目的主要是阐释设计思路，起到一个总览全局的作用。

请先阅读

[任务概述](../02_开发组/01_任务概述.md)

# 命名空间
暂定参考的命名空间如下：

    Blacksmith
    ├─ Controller
    │  ├─ Core
    │  │  ├─ ControllerBase.cs//控制器抽象基类
    │  │  ├─ IDriven<TContext, TResult>.cs//指令型控制器，受上一级控制
    │  │  └─ IObserver.cs//旁观者控制器，和上一级生命周期相同，它的特点是自动化
    │  │
    │  ├─ Game
    │  │  ├─ GameController.cs//游戏控制器，是整个控制器结构的最高点
    │  │  ├─ MindscapeController.cs//跳梦控制器1，作用是刷新节点
    │  │  ├─ MindscapeAnalyseController.cs//节点解析控制器，作用是解析节点类型
    │  │  └─ RunEndController.cs//进度控制器，作用是检查游戏进度到哪里了
    │  │
    │  ├─ Fight
    │  │  ├─ FightController.cs//战斗控制器，是整个战斗控制器结构的最高点
    │  │  ├─ RoundController.cs//回合控制器，作用是刷新回合
    │  │  ├─ JudgerController.cs//判定控制器，作用是控制子回合
    │  │  └─ FightRunEndController.cs//进度控制器，作用是检查游戏进度到哪里了
    │  │  
    │  │
    │  └─ Anecdote
    │  
    ├─ ParticularSystems
    │  └─ FightSystem 
    │
    ├─ GeneralSystems
    │  ├─ TendencySystem
    │  ├─ TrustLevelSystem
    │  ├─ GameDataSystem
    │  ├─ CurrentSituationSystem
    │  └─ CuriositySystem
    │
    │
    ├─ Presentation
    │  ├─ UI
    │  └─ VFX
    │
    └─ Utils
       ├─ Random
          ├─ Seed.cs//战斗控制器，是整个战斗控制器结构的最高点

# 设计思路
基本的思路是将肉鸽的主游戏流程视作一个递归。例如，开始界面->游戏开始->地图->进入节点->离开节点->地图->进入节点->离开节点->游戏结束->开始界面。可以看到这里有一个深度为2的递归。

同时还可以注意到，在地图里的时候开始界面是不工作的，至少不影响地图；在节点里的时候地图是不工作的，至少不影响节点。从这里出发，我们把肉鸽流程抽象为控制器模式。

总共有两种控制器。

第一种是指令型控制器。这种控制器的特点是只有受到指令的时候才工作。指令来自于它的上一级控制器。完成指令任务之后，它需要给上一级控制器返回一组数据。一个控制器可以有多个子控制器。

指令型控制器只约束要干的事情之间的前后继关系，不关心具体怎么做。

指令型控制器直接对应肉鸽的递归。因此，它还具有这样一个特点：只要父控制器给子控制器发送了指令，在得到返回前它的任务是卡住的。

第二种是观察者控制器。这种控制器的特点是是否工作可以受到父控制器的控制，但是不会卡住父控制器的任务。从上面我们可以看出，在控制器树里面，正在任务中的指令型控制器链不分叉。因此，观察者控制器不会卡住这个主进程。

为了便于控制，观察者控制器不能有子控制器。这样的话，它起到的就是一个真正的旁观者作用。因此，它现在不是我们讨论的重点。甚至如果后来发现它非必要，可以将其删除。

控制器如果被销毁，它的控制器子树也会被销毁。

为了防止逻辑过于复杂，控制器树的深度不超过3。如果有更深的逻辑可以考虑下沉到ParticularSystem中完成。

# 例子

接下来来看一局游戏中控制器模式是如何工作的，为了简单起见暂时不讨论控制器之间如何通信。

主控制器是GameController。它是一个指令性控制器，在游戏开始的时候创建，与这局游戏生命周期保持一致。

GameController之后创建三个指令型子控制器。一个是MindscapeController，作用是刷新节点。一个是MindscapeAnalyseController， 用于解析玩家选择的节点。另一个是RunEndController，作用是检查游戏进度。这三个控制器生命周期与GameController一致，在游戏中循环执行任务。

    MindscapeController->MindscapeAnalyseController->RunEndController

现在从MindscapeAnalyseController继续往下，因为其他两个没有子控制器了。

MindscapeAnalyseController解析出节点类型之后，创建一个指令型子控制器。具体是什么控制器与解析出的是什么节点有关。下面以战斗节点为例。

MindscapeAnalyseController解析出战斗节点之后，创建一个指令型子子控制器FightController。类似的，FightController创建三个指令型子控制器。一个是RoundController，作用是刷新回合。一个是JudgerController，作用是控制子回合内的游戏流程。另一个是FightRunEndController，作用是检查战斗进度。这三个控制器生命周期与FightController一致，在战斗中循环执行任务。

    RoundController->JudgerController->FightRunEndController

到这里就不会再有更多子树了。现在假设战斗结束，FightRunEndController将回调让FightController得知战斗结束，那么FightController回调让MindscapeAnalyseController得知节点事件结束，那么MindscapeAnalyseController回调让GameController得知要开始检查游戏进度（RunEndController）。

值得一提的是，完全有可能出现Anecdote节点事件进行到一半突然进入战斗的情况。这种情况下向MindscapeAnalyseController的回调就要包含战斗节点的信息，这样就能进入战斗节点。

# 控制器之间的通信原则
所有控制器都要继承自抽象基类ControllerBase。

控制器之间的通信使用显示接口与返回值完成

## 通信的基本原则
1. 指令只允许从父控制器发送到子控制器。

2. 结果只允许从子控制器发送到父控制器。

3. 当一个指令型控制器向其子控制器发送指令后，父控制器的当前任务进入等待状态，直到子控制器明确回调并返回结果，父控制器才可以继续执行后续逻辑。这一机制用于表达肉鸽流程中的强因果关系。

4. 观察者控制器不参与主控制流的递归，不阻塞父控制器，不影响指令型控制器链的执行顺序。观察者控制器只允许读取状态、统计信息或监听事件。

5. 父控制器和子控制器互相对对方是不可见的，只能持有对方的接口。

## 指令型控制器
指令型控制器要实现接口IDrivenIContext<TContext, TResult>，表明自身是受控的。这个接口同时提供上下文注入和返回。

## 观察者控制器
观察者控制器要实现接口IObserve，表明自身不参与主进程。

# 控制器接口
上面的两个接口是控制器系统最重要的约定。 

接下来先写出目前的想法

    public interface IDriven<TContext, TResult> where TResult : class
    {
        //父控制器注入初始化参数
        void InjectContext(TContext context);

        //父控制器通过这个成员函数来启动任务。任务最后修改result就相当于返回值
        IEnumerator Execute(TResult);
    }

    public interface IObserver
    {
        void SetSighted();//启动
        void SetBlind();//暂停
    }

父控制器如果要启动子控制器的任务，那么就相当于

    public IEnumerator Execute(ResultA){

        ...
        ResultB b = new ResultB(...);
        yield return StartCoroutine(DrivenInterface.Execute(b));
        ...

    }
    
对于观察者控制器，只要通过接口控制就没有问题。

这样做是object显示转换和持有对方类型引用折中的结果。控制器互相不持有对方类型的引用，而是显示指定上下文和返回结果，这样协议更加清楚，更方便即拆即用。由于是泛型接口，它不能完全消除耦合，这是编译器类型安全检查的代价。